.program blink
; turn on led for 100 cycles, then turn off for 100 cycles



; nop       0
; reset     10
; read      110
; write 0   1110
; write 1   1111

.side_set 1
.wrap_target
start:
    out x, 1            side 1 
    jmp !x, start       side 1 ; jump to start if 0 bit
    out x, 1            side 1 
    jmp !x, reset_pulse side 1 ; jump to reset pulse if first bit is zero
    out x, 1            side 1 
    jmp !x, read        side 1 ; jump to read if 2nd bit is zero
write:
    ; write if 2nd bit is 1
    out x, 1            side 0 ; 5  | write low, read bit from input_fifo 
    jmp !x, write_0     side 0 ; 10 | write low until 10us, jump to correct write_x
write_1:
    jmp start      [13] side 1 ; 70 | write 1 for 70uS then jump to start
write_0:
    jmp start      [13] side 0 ; 70 | write 0 for 70uS then jump to start
read:
    mov isr null        side 1 ; 5  | clear isr value, write 1
    nop                 side 0;  10 |
    set pindirs, 0      side 0 ; 15 | set pindir input
    in  pins, 1         side 0 ; 20 | read pins
    nop [15]            side 0 ; 80 | 
    push noblock        side 0 ; 85 | isr auto pushes to fifo, wait 10 cycles
    set pindirs, 1      side 1 ; 90 | set pindir output
    jmp start           side 1 ; 95 | return to start
; hold low for 480, wait 15, read for 300 
reset_pulse:
    set y, 5            side 1 ; write 1 for 5us
reset_loop:
    jmp y--, reset_loop [15] side 0  ; write 0 for 80uS (*6=480)
; now wait 3 cycles (=15uS), allow to go high again
    set pindirs, 0      side 0 ; 5  | set as input
    set y, 23           side 0 ; 10 | set y as loop var for 24 loops
    mov isr null        side 0 ; 15 | clear isr value
; for next 96 cycles (=480uS) look for presence pulse (logic low)
; 480/20 = 24 loops
reset_wait_loop:
    in pins, 1              [2] side 0 ; 15 | read prescence
    jmp y--, reset_wait_loop    side 0 ; 20 | loop

    push noblock                side 1 ; 5  | push isr to fifo  
    set pindirs, 1              side 1 ; 10 |set pin as output    
.wrap


% c-sdk {

// Helper function (for use in C program) to initialize this PIO program
void blink_program_init(PIO pio, uint sm, uint offset, uint pin, float div) {

    // Sets up state machine and wrap target. This function is automatically
    // generated in blink.pio.h.
    pio_sm_config c = blink_program_get_default_config(offset);

    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, pin);
    gpio_pull_up(pin);


    // Connect pin to SET pin (control with 'set' instruction)
    sm_config_set_set_pins(&c, pin, 1);
    sm_config_set_in_pins(&c, pin); 
    sm_config_set_out_pins(&c, pin, 1); 
    sm_config_set_sideset_pins(&c, pin);
    sm_config_set_out_shift(&c, true, true, 4);
    sm_config_set_in_shift(&c, false, false, 32);
    
    // Set the pin direction to output (in PIO)
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);
    
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);

    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

%}